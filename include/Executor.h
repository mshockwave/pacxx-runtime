//
// Created by mhaidl on 29/05/16.
//

#ifndef PACXX_V2_EXECUTOR_H
#define PACXX_V2_EXECUTOR_H

#include <cuda.h>

#include <llvm/IR/Module.h>
#include <memory>
#include <string>
#include <algorithm>
#include <detail/DeviceBuffer.h>

#include "detail/cuda/CUDARuntime.h"
#include "detail/common/Exceptions.h"
#include "detail/IRRuntime.h"
#include "CodePolicy.h"
#include "detail/CoreInitializer.h"
#include "detail/IRCompiler.h"
#include "detail/common/Log.h"
#include "detail/cuda/PTXBackend.h"
#include "detail/KernelConfiguration.h"

namespace pacxx {
namespace v2 {
class Executor {
public:
  template <typename CompilerT, typename RuntimeT>
  Executor(std::unique_ptr<llvm::Module> M,
           CodePolicy<CompilerT, RuntimeT> &&policy)
      : _M(std::move(M)), _compiler(std::make_unique<CompilerT>()),
        _runtime(std::make_unique<RuntimeT>(0)) {// TODO: make dynamic fo different devices
    core::CoreInitializer::initialize();

    _compiler->initialize();
    _runtime->linkMC(_compiler->compile(*_M));
  }

  template <typename... Args> void run(std::string name, KernelConfiguration&& config, Args &&... args) {

    const std::string prefix("_ZN5pacxx13genericKernelILm");

    const Function* F = nullptr;
    if (std::equal(prefix.begin(), prefix.end(), name.begin())){ // this is a kernel generated by clang
      auto it = name.begin()+prefix.size();
      std::string number(it, it+1);
      auto N = std::stoul(number);
      __message("calling kernel #", N);
      for (const auto& func : _M->functions())
      {
        if (func.getName().startswith(prefix + number))
          F = &func;
      }
    }
    else { // the kernel is from somewhere else, just ask for the function with matching name (fail if not found)
      F = _M->getFunction(name);
    }
    if (!F)
      throw common::generic_exception("Kernel function not found in module!");

    size_t buffer_size = 0;
    std::vector<size_t> arg_sizes(F->arg_size());

    std::transform(F->arg_begin(), F->arg_end(), arg_sizes.begin(), [&](const auto& arg){
      auto arg_size = _M->getDataLayout().getTypeAllocSize(arg.getType());
      auto arg_alignment =
          _M->getDataLayout().getPrefTypeAlignment(arg.getType());
      if (arg_size <= arg_alignment)
        buffer_size += arg_alignment;
      else
        buffer_size +=
            arg_size * (static_cast<size_t>(arg_size / arg_alignment) + 1);

      return arg_size;
    });

    std::vector<char> args_buffer(buffer_size);
    auto ptr = args_buffer.data();
    size_t i = 0;
    common::for_each_in_arg_pack([&](auto &&arg) {
      auto size = arg_sizes[i++];
      std::memcpy(ptr, &arg, size);
      ptr += size;
    }, std::forward<Args>(args)...);

    auto& K = _runtime->getKernel(F->getName().str());
    K.configurate(config);
    K.setArguments(args_buffer);
    K.launch();
  }

  template <typename T> DeviceBuffer<T>& allocate(size_t count){
    DeviceBufferBase* ptr = _runtime->allocateMemory(count * sizeof(T));
    return *static_cast<DeviceBuffer<T>*>(ptr);
  }

private:
  std::unique_ptr<llvm::Module> _M;
  std::unique_ptr<IRCompiler> _compiler;
  std::unique_ptr<IRRuntime> _runtime;
};
}
}

#endif // PACXX_V2_EXECUTOR_H
